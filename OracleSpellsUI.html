import React, { useState, useEffect } from 'react';
import { Search, Filter, X } from 'lucide-react';
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";

const SpellDatabase = () => {
  const [spells, setSpells] = useState([]);
  const [filteredSpells, setFilteredSpells] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  // State for saved preferences and favorites
  const [favoriteSpells, setFavoriteSpells] = useState([]);
  const [lastUpdate, setLastUpdate] = useState(null);
  
  // Initialize IndexedDB
  useEffect(() => {
    const initDB = async () => {
      const request = indexedDB.open('SpellsDatabase', 1);
      
      request.onerror = (event) => {
        console.error('IndexedDB error:', event.target.error);
        setError('Failed to initialize local database');
      };

      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains('spells')) {
          db.createObjectStore('spells', { keyPath: 'name' });
        }
        if (!db.objectStoreNames.contains('favorites')) {
          db.createObjectStore('favorites', { keyPath: 'name' });
        }
      };
    };

    initDB();
  }, []);

  // Load saved preferences from localStorage
  useEffect(() => {
    const savedFilters = localStorage.getItem('spellFilters');
    if (savedFilters) {
      setFilters(JSON.parse(savedFilters));
    }
    
    const savedFavorites = localStorage.getItem('favoriteSpells');
    if (savedFavorites) {
      setFavoriteSpells(JSON.parse(savedFavorites));
    }
    
    const savedUpdate = localStorage.getItem('lastSpellUpdate');
    if (savedUpdate) {
      setLastUpdate(new Date(savedUpdate));
    }
  }, []);

  // Save preferences to localStorage when they change
  useEffect(() => {
    localStorage.setItem('spellFilters', JSON.stringify(filters));
  }, [filters]);

  useEffect(() => {
    localStorage.setItem('favoriteSpells', JSON.stringify(favoriteSpells));
  }, [favoriteSpells]);

  // Function to save spells to IndexedDB
  const saveSpellsLocally = async (spellData) => {
    const request = indexedDB.open('SpellsDatabase', 1);
    
    request.onsuccess = (event) => {
      const db = event.target.result;
      const transaction = db.transaction(['spells'], 'readwrite');
      const store = transaction.objectStore('spells');
      
      // Clear existing data
      store.clear();
      
      // Add new data
      spellData.forEach(spell => {
        store.add(spell);
      });
      
      // Update last update timestamp
      const now = new Date();
      setLastUpdate(now);
      localStorage.setItem('lastSpellUpdate', now.toISOString());
    };
  };

  // Function to load spells from IndexedDB
  const loadLocalSpells = async () => {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('SpellsDatabase', 1);
      
      request.onsuccess = (event) => {
        const db = event.target.result;
        const transaction = db.transaction(['spells'], 'readonly');
        const store = transaction.objectStore('spells');
        const getAllRequest = store.getAll();
        
        getAllRequest.onsuccess = () => {
          resolve(getAllRequest.result);
        };
        
        getAllRequest.onerror = () => {
          reject(getAllRequest.error);
        };
      };
      
      request.onerror = () => {
        reject(request.error);
      };
    });
  };
    search: '',
    type: 'All',
    sort: 'Level',
    actions: 'Any',
    traditions: ['Divine', 'Oracle']
  });
  const [showFilterModal, setShowFilterModal] = useState(false);
  const [selectedSpell, setSelectedSpell] = useState(null);
  const [expandedLevel, setExpandedLevel] = useState(null);

  useEffect(() => {
    const loadSpells = async () => {
      try {
        setLoading(true);
        const response = await fetch('https://raw.githubusercontent.com/davidaerne/OracleSpells/76953dbcbc7738dbfc8352de3165b315a63312ea/spells.json');
        if (!response.ok) {
          throw new Error('Failed to fetch spells data');
        }
        const data = await response.json();
        
        // Process and validate the data
        const processedSpells = data.map(spell => ({
          ...spell,
          traditions: spell.traditions || [],
          traits: spell.traits || [],
          level: spell.level || (spell.traits?.includes('Cantrip') ? '0' : '1')
        }));
        
        setSpells(processedSpells);
        setFilteredSpells(processedSpells);
        setLoading(false);
      } catch (err) {
        console.error('Error loading spells:', err);
        setError(err.message);
        setLoading(false);
      }
    };

    loadSpells();
  }, []);

  useEffect(() => {
    if (spells.length > 0) {
      applyFilters();
    }
  }, [filters, spells]);

  const isCantrip = (spell) => {
    const traitsLower = (spell.traits || []).map(t => t.toLowerCase());
    const typeLower = (spell.type || '').toLowerCase();
    return traitsLower.includes('cantrip') || typeLower === 'cantrip';
  };

  const getSpellLevel = (spell) => {
    if (isCantrip(spell)) return 0;
    const num = parseInt(spell.level, 10);
    return isNaN(num) ? -1 : num;
  };

  const actionMatches = (spell, actionVal) => {
    if (actionVal === 'Any') return true;
    const act = (spell.action || '').trim();
    const actMax = (spell.actionMax || '').trim();
    switch (actionVal) {
      case '1': return (act === '1' || actMax === '1');
      case '2': return (act === '2' || actMax === '2');
      case '3': return (act === '3' || actMax === '3');
      case '1-3': return (actMax === '3');
      default: return true;
    }
  };

  const applyFilters = () => {
    let filtered = spells.filter(spell => {
      const traditions = (spell.traditions || []).map(t => t.toLowerCase());
      const traits = (spell.traits || []).map(t => t.toLowerCase());
      const combined = [...traditions, ...traits];
      
      // Filter by selected traditions
      if (filters.traditions.length > 0) {
        const hasSelectedTradition = filters.traditions.some(tradition => 
          combined.includes(tradition.toLowerCase())
        );
        if (!hasSelectedTradition) return false;
      }
      
      if (filters.type === 'Cantrip' && !isCantrip(spell)) return false;
      if (filters.type === 'Spell' && isCantrip(spell)) return false;
      
      if (filters.search) {
        const searchLower = filters.search.toLowerCase();
        const inName = spell.name.toLowerCase().includes(searchLower);
        const inTrait = traits.some(t => t.includes(searchLower));
        if (!inName && !inTrait) return false;
      }
      
      if (!actionMatches(spell, filters.actions)) return false;
      
      return true;
    });

    if (filters.sort === 'Level') {
      filtered.sort((a, b) => getSpellLevel(a) - getSpellLevel(b));
    } else {
      filtered.sort((a, b) => a.name.localeCompare(b.name));
    }

    setFilteredSpells(filtered);
  };

  const ActionCircle = ({ count }) => (
    <span className="inline-flex items-center justify-center w-6 h-6 rounded-full bg-gray-800 text-white font-bold mx-1">
      {count}
    </span>
  );

  const SpellLevelGroup = ({ level, spells }) => {
    const isExpanded = expandedLevel === level;
    const levelText = level === 0 ? 'Cantrips' : `Level ${level}`;

    return (
      <div className="mb-4">
        <button
          onClick={() => setExpandedLevel(isExpanded ? null : level)}
          className="w-full p-4 text-left bg-gray-100 hover:bg-gray-200 rounded-lg mb-2 font-semibold"
        >
          {levelText}
        </button>
        {isExpanded && (
          <div className="space-y-2">
            {spells.map((spell, idx) => (
              <div
                key={idx}
                onClick={() => setSelectedSpell(spell)}
                className="p-4 bg-white rounded-lg shadow hover:shadow-md cursor-pointer"
              >
                <div className="font-semibold">{spell.name}</div>
                <div className="text-sm text-gray-600">
                  Traits: {(spell.traits || []).join(', ')}
                </div>
                <div className="flex justify-between text-sm text-gray-600 mt-2">
                  <div>
                    Actions: {spell.actionMax ? (
                      <>
                        <ActionCircle count={spell.action} /> to <ActionCircle count={spell.actionMax} />
                      </>
                    ) : (
                      <ActionCircle count={spell.action} />
                    )}
                  </div>
                  <div>{spell.range ? `Range: ${spell.range}` : ''}</div>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    );
  };

  const FilterModal = () => (
    <div className={`fixed inset-0 bg-black bg-opacity-50 z-50 ${showFilterModal ? 'flex' : 'hidden'} items-center justify-center`}>
      <Card className="w-full max-w-md mx-4">
        <CardHeader>
          <div className="flex justify-between items-center">
            <CardTitle>Filter Options</CardTitle>
            <button onClick={() => setShowFilterModal(false)} className="text-gray-500 hover:text-gray-700">
              <X size={24} />
            </button>
          </div>
        </CardHeader>
        <CardContent className="space-y-4">
          <div>
            <label className="block mb-2 font-medium">Search</label>
            <input
              type="text"
              value={filters.search}
              onChange={e => setFilters({ ...filters, search: e.target.value })}
              className="w-full p-2 border rounded"
              placeholder="Name or Trait"
            />
          </div>
          <div>
            <label className="block mb-2 font-medium">Traditions</label>
            <select
              multiple
              value={filters.traditions}
              onChange={(e) => {
                const selected = Array.from(e.target.selectedOptions, option => option.value);
                setFilters({ ...filters, traditions: selected });
              }}
              className="w-full p-2 border rounded"
              size="4"
            >
              <option value="Arcane">Arcane</option>
              <option value="Divine">Divine</option>
              <option value="Occult">Occult</option>
              <option value="Primal">Primal</option>
              <option value="Oracle">Oracle</option>
            </select>
          </div>
          <div>
            <label className="block mb-2 font-medium">Type</label>
            <select
              value={filters.type}
              onChange={e => setFilters({ ...filters, type: e.target.value })}
              className="w-full p-2 border rounded"
            >
              <option value="All">All</option>
              <option value="Spell">Spell</option>
              <option value="Cantrip">Cantrip</option>
            </select>
          </div>
          <div>
            <label className="block mb-2 font-medium">Sort By</label>
            <select
              value={filters.sort}
              onChange={e => setFilters({ ...filters, sort: e.target.value })}
              className="w-full p-2 border rounded"
            >
              <option value="Level">Level</option>
              <option value="Name">Name</option>
            </select>
          </div>
          <div>
            <label className="block mb-2 font-medium">Action Count</label>
            <select
              value={filters.actions}
              onChange={e => setFilters({ ...filters, actions: e.target.value })}
              className="w-full p-2 border rounded"
            >
              <option value="Any">Any</option>
              <option value="1">1 action</option>
              <option value="2">2 actions</option>
              <option value="3">3 actions</option>
              <option value="1-3">1-3 actions</option>
            </select>
          </div>
          <div className="flex justify-end gap-2 pt-4">
            <button
              onClick={() => {
                setFilters({
                  search: '',
                  type: 'All',
                  sort: 'Level',
                  actions: 'Any'
                });
                setShowFilterModal(false);
              }}
              className="px-4 py-2 bg-gray-200 rounded hover:bg-gray-300"
            >
              Reset
            </button>
            <button
              onClick={() => {
                setShowFilterModal(false);
              }}
              className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
            >
              Apply
            </button>
          </div>
        </CardContent>
      </Card>
    </div>
  );

  const SpellDetailModal = () => {
    if (!selectedSpell) return null;

    const isFavorite = favoriteSpells.includes(selectedSpell.name);

    const toggleFavorite = () => {
      if (isFavorite) {
        setFavoriteSpells(favoriteSpells.filter(name => name !== selectedSpell.name));
      } else {
        setFavoriteSpells([...favoriteSpells, selectedSpell.name]);
      }
    };

    const formatDescription = (desc) => {
      if (!desc) return '(No description)';
      return desc
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/(Heightened\s*\(\+?\d+\)|Heightened\s*\(\d+(?:st|nd|rd|th)\))/gi, '<br>$1')
        .replace(/\|(\d+)\|\s*/g, '<span class="action-circle">$1</span> ');
    };

    return (
      <div className="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4">
        <Card className="w-full max-w-2xl max-h-[90vh] overflow-y-auto">
          <CardHeader>
            <div className="flex justify-between items-start">
              <div>
                <CardTitle>{selectedSpell.name}</CardTitle>
                <div className="text-sm text-gray-600 mt-1">
                  {getSpellLevel(selectedSpell) > 0 ? `Spell Level ${getSpellLevel(selectedSpell)}` : 'Cantrip'}
                </div>
                <div className="text-sm text-gray-600">
                  Traits: {(selectedSpell.traits || []).join(', ')}
                </div>
              </div>
              <button onClick={() => setSelectedSpell(null)} className="text-gray-500 hover:text-gray-700">
                <X size={24} />
              </button>
            </div>
          </CardHeader>
          <CardContent className="space-y-4">
            <div>
              <div className="font-semibold mb-1">Cast</div>
              <div>{selectedSpell.cast || '(No casting time specified)'}</div>
            </div>
            <div>
              <div className="font-semibold mb-1">Range</div>
              <div>{selectedSpell.range || '(No range specified)'}</div>
            </div>
            {selectedSpell.targets && (
              <div>
                <div className="font-semibold mb-1">Targets</div>
                <div>{selectedSpell.targets}</div>
              </div>
            )}
            {selectedSpell['saving throw'] && (
              <div>
                <div className="font-semibold mb-1">Saving Throw</div>
                <div>{selectedSpell['saving throw']}</div>
              </div>
            )}
            <div>
              <div className="font-semibold mb-1">Description</div>
              <div dangerouslySetInnerHTML={{ 
                __html: formatDescription(selectedSpell.description) 
              }} />
            </div>
          </CardContent>
        </Card>
      </div>
    );
  };

  return (
    <div className="min-h-screen bg-gray-50">
      <header className="bg-white shadow">
        <div className="max-w-7xl mx-auto px-4 py-4 sm:px-6 lg:px-8 flex justify-between items-center">
          <h1 className="text-xl font-bold">Oracle Spell List</h1>
          <div className="flex gap-2">
            <button
              onClick={() => setShowFilterModal(true)}
              className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 flex items-center gap-2"
            >
              <Filter size={18} />
              Filter
            </button>
            <button
              onClick={() => {
                setFilters({
                  search: '',
                  type: 'All',
                  sort: 'Level',
                  actions: 'Any'
                });
              }}
              className="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700"
            >
              Clear Filter
            </button>
          </div>
        </div>
      </header>

      <main className="max-w-7xl mx-auto px-4 py-6 sm:px-6 lg:px-8">
        {loading && (
          <div className="flex justify-center items-center min-h-[200px]">
            <div className="text-lg text-gray-600">Loading spells...</div>
          </div>
        )}
        
        {error && (
          <div className="bg-red-50 border border-red-200 rounded-lg p-4 text-red-700">
            Error loading spells: {error}
          </div>
        )}

        {!loading && !error && filteredSpells.length === 0 && (
          <div className="text-center py-8 text-gray-600">
            No spells found matching your criteria
          </div>
        )}

        {!loading && !error && (
          Object.entries(
            filteredSpells.reduce((acc, spell) => {
              const level = getSpellLevel(spell);
              if (!acc[level]) acc[level] = [];
              acc[level].push(spell);
              return acc;
            }, {})
          )
          .sort(([a], [b]) => Number(a) - Number(b))
          .map(([level, spells]) => (
            <SpellLevelGroup 
              key={level} 
              level={Number(level)} 
              spells={spells} 
            />
          ))
        )}
      </main>

      <FilterModal />
      <SpellDetailModal />
    </div>
  );
};

export default SpellDatabase;
